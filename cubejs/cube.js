// Cube.js main configuration
// Handles multi-tenant DuckDB, JWT auth, and row-level security via queryRewrite

const jwt = require('jsonwebtoken');

module.exports = {
  // ──────────────────────────────────────────────────────────────────────────
  // Database connection — DuckDB read-only
  // ──────────────────────────────────────────────────────────────────────────
  driverFactory: ({ dataSource }) => {
    const { DuckDBDriver } = require('@cubejs-backend/duckdb-driver');
    return new DuckDBDriver({
      database: process.env.CUBEJS_DB_DUCKDB_DATABASE_PATH || '/data/cpg_multi_tenant.duckdb',
      // DuckDB is opened read-only to prevent accidental writes
      readOnly: true,
    });
  },

  // ──────────────────────────────────────────────────────────────────────────
  // Multi-tenancy: each client gets its own compiled schema
  // The APP_ID determines which DuckDB schema namespace is used
  // ──────────────────────────────────────────────────────────────────────────
  contextToAppId: ({ securityContext }) => {
    const clientId = (securityContext && securityContext.clientId) || 'nestle';
    return `APP_${clientId.toUpperCase()}`;
  },

  // Each tenant gets its own pre-agg cache namespace
  contextToOrchestratorId: ({ securityContext }) => {
    const clientId = (securityContext && securityContext.clientId) || 'nestle';
    return `ORCH_${clientId.toUpperCase()}`;
  },

  // ──────────────────────────────────────────────────────────────────────────
  // JWT authentication
  // Validates the token generated by Flask (security/cubejs_token.py)
  // ──────────────────────────────────────────────────────────────────────────
  checkAuth: async (req, auth) => {
    if (!auth) {
      throw new Error('No authorization token provided');
    }
    try {
      const secret = process.env.CUBEJS_API_SECRET;
      if (!secret) {
        throw new Error('CUBEJS_API_SECRET not configured');
      }
      // jwt.verify throws if invalid / expired
      const payload = jwt.verify(auth, secret, { algorithms: ['HS256'] });
      req.securityContext = payload;
    } catch (e) {
      throw new Error(`JWT verification failed: ${e.message}`);
    }
  },

  // ──────────────────────────────────────────────────────────────────────────
  // Row-Level Security via queryRewrite
  // Hierarchy-restricted roles (SO/ASM/ZSM) get their code injected as a filter
  // Admin/NSM/analyst see all data — no extra filter added
  // ──────────────────────────────────────────────────────────────────────────
  queryRewrite: (query, { securityContext }) => {
    if (!securityContext) return query;

    const { role, hierarchy_code } = securityContext;
    const restrictedRoles = ['SO', 'ASM', 'ZSM'];

    if (restrictedRoles.includes(role) && hierarchy_code) {
      // Map role → DimSalesHierarchy dimension
      const roleToMember = {
        SO:  'DimSalesHierarchy.so_code',
        ASM: 'DimSalesHierarchy.asm_code',
        ZSM: 'DimSalesHierarchy.zsm_code',
      };

      const filterMember = roleToMember[role];
      if (filterMember) {
        query.filters = query.filters || [];
        query.filters.push({
          member: filterMember,
          operator: 'equals',
          values: [hierarchy_code],
        });
      }
    }

    return query;
  },

  // ──────────────────────────────────────────────────────────────────────────
  // Schema path — points to our multi-tenant cube definitions
  // ──────────────────────────────────────────────────────────────────────────
  schemaPath: 'schema',

  // ──────────────────────────────────────────────────────────────────────────
  // API port
  // ──────────────────────────────────────────────────────────────────────────
  http: {
    port: 4000,
  },

  // Development logger — set to false in production
  logger: (msg, params) => {
    if (process.env.NODE_ENV !== 'production') {
      console.log(`[Cube.js] ${msg}`, params || '');
    }
  },
};
